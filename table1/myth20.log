nohup: ignoring input
==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: Overflow_Add
Function name: add(uint256)
PC address: 191
Estimated Gas Usage: 642 - 737
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/overflow_simple_add_fixed.sol:12

a + b

--------------------


The analysis was completed successfully. No issues were detected.

==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: IntegerOverflowMul
Function name: run(uint256)
PC address: 174
Estimated Gas Usage: 635 - 730
The binary multiplication can overflow.
The operands of the multiplication operation are not sufficiently constrained. The multiplication could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/integer_overflow_mul.sol:10

count *= input

--------------------


==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: SimpleDAO
Function name: donate(address)
PC address: 444
Estimated Gas Usage: 682 - 967
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/simple_dao.sol:11

credit[to] += msg.value

--------------------

==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Medium
Contract: SimpleDAO
Function name: withdraw(uint256)
PC address: 565
Estimated Gas Usage: 765 - 1236
A call to a user-supplied address is executed.
The callee address of an external message call can be set by the caller. Note that the callee can contain arbitrary code and may re-enter any function in this contract. Review the business logic carefully to prevent averse effects on thecontract state.
--------------------
In file: cases/simple_dao.sol:16

msg.sender.call.value(amount)()

--------------------


The analysis was completed successfully. No issues were detected.

==== Integer Underflow ====
SWC ID: 101
Severity: High
Contract: IntegerOverflowMappingSym1
Function name: init(uint256,uint256)
PC address: 145
Estimated Gas Usage: 716 - 1001
The binary subtraction can underflow.
The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.
--------------------
In file: cases/integer_overflow_mapping_sym_1.sol:9

map[k] -= v

--------------------


==== Dependence on Predictable Variable ====
SWC ID: 120
Severity: Low
Contract: PredictTheBlockHashChallenge
Function name: settle()
PC address: 498
Estimated Gas Usage: 6887 - 27928
Sending of Ether depends on the blockhash.
The predictable expression 'block.blockhash(block.number)' is used to determine Ether recipient, this expression will always be equal to zero.
--------------------
In file: cases/old_blockhash.sol:33

msg.sender.transfer(2 ether)

--------------------

==== Dependence on predictable environment variable ====
SWC ID: 120
Severity: Low
Contract: PredictTheBlockHashChallenge
Function name: settle()
PC address: 498
Estimated Gas Usage: 6887 - 27928
Sending of Ether depends on a predictable variable.
The contract sends Ether depending on the values of the following variables:
- block.number
- block.number
Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions.
--------------------
In file: cases/old_blockhash.sol:33

msg.sender.transfer(2 ether)

--------------------

==== Unprotected Ether Withdrawal ====
SWC ID: 105
Severity: High
Contract: PredictTheBlockHashChallenge
Function name: settle()
PC address: 498
Estimated Gas Usage: 6887 - 27928
Anyone can withdraw ETH from the contract account.
Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent an equivalent amount of ETH to it. This is likely to be a vulnerability.
--------------------
In file: cases/old_blockhash.sol:33

msg.sender.transfer(2 ether)

--------------------

==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: PredictTheBlockHashChallenge
Function name: lockInGuess(bytes32)
PC address: 705
Estimated Gas Usage: 5969 - 26634
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/old_blockhash.sol:23

block.number + 1

--------------------


==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: PredictTheBlockHashChallenge
Function name: settle()
PC address: 211
Estimated Gas Usage: 645 - 930
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/old_blockhash_fixed.sol:27

guesses[msg.sender].block +10

--------------------

==== Integer Underflow ====
SWC ID: 101
Severity: High
Contract: PredictTheBlockHashChallenge
Function name: settle()
PC address: 295
Estimated Gas Usage: 1171 - 1646
The binary subtraction can underflow.
The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.
--------------------
In file: cases/old_blockhash_fixed.sol:30

guesses[msg.sender].block - block.number

--------------------

==== Dependence on Predictable Variable ====
SWC ID: 120
Severity: Low
Contract: PredictTheBlockHashChallenge
Function name: settle()
PC address: 578
Estimated Gas Usage: 7418 - 28649
Sending of Ether depends on the blockhash.
The predictable expression 'block.blockhash(block.number)' is used to determine Ether recipient, this expression will always be equal to zero.
--------------------
In file: cases/old_blockhash_fixed.sol:35

msg.sender.transfer(2 ether)

--------------------

==== Dependence on predictable environment variable ====
SWC ID: 120
Severity: Low
Contract: PredictTheBlockHashChallenge
Function name: settle()
PC address: 578
Estimated Gas Usage: 7418 - 28649
Sending of Ether depends on a predictable variable.
The contract sends Ether depending on the values of the following variables:
- block.number
- block.number
- block.number
- block.number
Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions.
--------------------
In file: cases/old_blockhash_fixed.sol:35

msg.sender.transfer(2 ether)

--------------------

==== Unprotected Ether Withdrawal ====
SWC ID: 105
Severity: High
Contract: PredictTheBlockHashChallenge
Function name: settle()
PC address: 578
Estimated Gas Usage: 7418 - 28649
Anyone can withdraw ETH from the contract account.
Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent an equivalent amount of ETH to it. This is likely to be a vulnerability.
--------------------
In file: cases/old_blockhash_fixed.sol:35

msg.sender.transfer(2 ether)

--------------------

==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: PredictTheBlockHashChallenge
Function name: lockInGuess(bytes32)
PC address: 938
Estimated Gas Usage: 5969 - 26634
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/old_blockhash_fixed.sol:23

block.number + 1

--------------------


The analysis was completed successfully. No issues were detected.

The analysis was completed successfully. No issues were detected.

The analysis was completed successfully. No issues were detected.

==== Dependence on Predictable Variable ====
SWC ID: 120
Severity: Low
Contract: GuessTheRandomNumberChallenge
Function name: guess(uint8)
PC address: 269
Estimated Gas Usage: 730 - 1341
Sending of Ether depends on the blockhash.
The predictable expression 'block.blockhash(block.number)' is used to determine Ether recipient, this expression will always be equal to zero.
--------------------
In file: cases/guess_the_random_number.sol:25

msg.sender.transfer(2 ether)

--------------------

==== Dependence on predictable environment variable ====
SWC ID: 120
Severity: Low
Contract: GuessTheRandomNumberChallenge
Function name: guess(uint8)
PC address: 269
Estimated Gas Usage: 730 - 1341
Sending of Ether depends on a predictable variable.
The contract sends Ether depending on the values of the following variables:
- block.number
Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions.
--------------------
In file: cases/guess_the_random_number.sol:25

msg.sender.transfer(2 ether)

--------------------

==== Unprotected Ether Withdrawal ====
SWC ID: 105
Severity: High
Contract: GuessTheRandomNumberChallenge
Function name: guess(uint8)
PC address: 269
Estimated Gas Usage: 730 - 1341
Anyone can withdraw ETH from the contract account.
Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent an equivalent amount of ETH to it. This is likely to be a vulnerability.
--------------------
In file: cases/guess_the_random_number.sol:25

msg.sender.transfer(2 ether)

--------------------


==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: HumanStandardToken
Function name: [approve(address,uint256), approve(address,uint256), approve(address,uint256)] (ambiguous)
PC address: 394
Estimated Gas Usage: 16758 - 80754
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/SpankChain.sol:90

function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

--------------------

==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: StandardToken
Function name: [transferFrom(address,address,uint256), transferFrom(address,address,uint256), transferFrom(address,address,uint256)] (ambiguous)
PC address: 1243
Estimated Gas Usage: 1949 - 2804
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/SpankChain.sol:79

balances[_to] += _value

--------------------

==== Integer Underflow ====
SWC ID: 101
Severity: High
Contract: StandardToken
Function name: [transferFrom(address,address,uint256), transferFrom(address,address,uint256), transferFrom(address,address,uint256)] (ambiguous)
PC address: 1320
Estimated Gas Usage: 7472 - 28517
The binary subtraction can underflow.
The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.
--------------------
In file: cases/SpankChain.sol:80

balances[_from] -= _value

--------------------


The analysis was completed successfully. No issues were detected.

==== Integer Underflow ====
SWC ID: 101
Severity: High
Contract: IntegerOverflowMultiTxMultiFuncFeasible
Function name: run(uint256)
PC address: 218
Estimated Gas Usage: 1059 - 1154
The binary subtraction can underflow.
The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.
--------------------
In file: cases/integer_overflow_multitx_multifunc_feasible.sol:24

count -= input

--------------------


==== Unchecked Call Return Value ====
SWC ID: 104
Severity: Low
Contract: SecureAuction
Function name: withdraw()
PC address: 566
Estimated Gas Usage: 6540 - 61201
The return value of a message call is not checked.
External calls return a boolean value. If the callee contract halts with an exception, 'false' is returned and execution continues in the caller. It is usually recommended to wrap external calls into a require statement to prevent unexpected states.
--------------------
In file: cases/auction.sol:51

msg.sender.send(refund)

--------------------


==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: Token
Function name: [transferFrom(address,address,uint256), transferFrom(address,address,uint256), transferFrom(address,address,uint256), transferFrom(address,address,uint256)] (ambiguous)
PC address: 1260
Estimated Gas Usage: 2001 - 2856
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/DAO.sol:121

balances[_to] += _amount

--------------------

==== Integer Underflow ====
SWC ID: 101
Severity: High
Contract: Token
Function name: [transferFrom(address,address,uint256), transferFrom(address,address,uint256), transferFrom(address,address,uint256), transferFrom(address,address,uint256)] (ambiguous)
PC address: 1336
Estimated Gas Usage: 7524 - 28569
The binary subtraction can underflow.
The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.
--------------------
In file: cases/DAO.sol:122

balances[_from] -= _amount

--------------------


==== Integer Underflow ====
SWC ID: 101
Severity: High
Contract: IntegerOverflowMultiTxOneFuncFeasible
Function name: run(uint256)
PC address: 196
Estimated Gas Usage: 1059 - 1154
The binary subtraction can underflow.
The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.
--------------------
In file: cases/integer_overflow_multitx_onefunc_feasible.sol:21

count -= input

--------------------


==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: SimpleDAO
Function name: donate(address)
PC address: 444
Estimated Gas Usage: 682 - 967
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/simple_dao_fixed.sol:11

credit[to] += msg.value

--------------------

==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Medium
Contract: SimpleDAO
Function name: withdraw(uint256)
PC address: 641
Estimated Gas Usage: 6287 - 26948
A call to a user-supplied address is executed.
The callee address of an external message call can be set by the caller. Note that the callee can contain arbitrary code and may re-enter any function in this contract. Review the business logic carefully to prevent averse effects on thecontract state.
--------------------
In file: cases/simple_dao_fixed.sol:17

msg.sender.call.value(amount)()

--------------------


==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: Overflow_Add
Function name: add(uint256)
PC address: 168
Estimated Gas Usage: 611 - 706
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/overflow_simple_add.sol:7

balance += deposit

--------------------


The analysis was completed successfully. No issues were detected.

==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: Overflow
Function name: add(uint256)
PC address: 229
Estimated Gas Usage: 614 - 709
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/theRun.sol:7

sellerBalance += value

--------------------

==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: Overflow
Function name: safe_add(uint256)
PC address: 250
Estimated Gas Usage: 1032 - 1127
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/integer_overflow_1.sol:14

value + sellerBalance

--------------------


==== Unchecked Call Return Value ====
SWC ID: 104
Severity: Low
Contract: theRun
Function name: fallback
PC address: 884
Estimated Gas Usage: 1202 - 35483
The return value of a message call is not checked.
External calls return a boolean value. If the callee contract halts with an exception, 'false' is returned and execution continues in the caller. It is usually recommended to wrap external calls into a require statement to prevent unexpected states.
--------------------
In file: cases/theRun.sol:42

msg.sender.send(msg.value)

--------------------

==== Exception State ====
SWC ID: 110
Severity: Low
Contract: theRun
Function name: PlayerInfo(uint256)
PC address: 1213
Estimated Gas Usage: 1103 - 1198
A reachable exception has been detected.
It is possible to trigger an exception (opcode 0xfe). Exceptions can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. Note that explicit `assert()` should only be used to check invariants. Use `require()` for regular input checking.
--------------------
In file: cases/theRun.sol:162

players[id]

--------------------

==== Exception State ====
SWC ID: 110
Severity: Low
Contract: theRun
Function name: NextPayout()
PC address: 1646
Estimated Gas Usage: 1096 - 1191
A reachable exception has been detected.
It is possible to trigger an exception (opcode 0xfe). Exceptions can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. Note that explicit `assert()` should only be used to check invariants. Use `require()` for regular input checking.
--------------------
In file: cases/theRun.sol:140

players[Payout_id]

--------------------


find: ‘myth’ terminated by signal 9
==== Multiple Calls in a Single Transaction ====
SWC ID: 113
Severity: Medium
Contract: Refunder
Function name: refundAll()
PC address: 103
Estimated Gas Usage: 7767 - 78314
Multiple sends are executed in one transaction.
Consecutive calls are executed at the following bytecode offsets:
Offset: 431
Offset: 431
Try to isolate each external call into its own transaction, as external calls can fail accidentally or deliberately.

--------------------
In file: cases/sendloop.sol:20

function refundAll() public {
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
            require(refundAddresses[x].send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }

--------------------


==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Medium
Contract: ModifierEntrancy
Function name: airDrop()
PC address: 371
Estimated Gas Usage: 1451 - 2017
A call to a user-supplied address is executed.
The callee address of an external message call can be set by the caller. Note that the callee can contain arbitrary code and may re-enter any function in this contract. Review the business logic carefully to prevent averse effects on thecontract state.
--------------------
In file: cases/modifier_reentrancy.sol:14

Bank(msg.sender).supportsToken()

--------------------


==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: GuessTheRandomNumberChallenge
Function name: recover()
PC address: 360
Estimated Gas Usage: 591 - 686
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/guess_the_random_number_fixed.sol:31

commitBlock + 20

--------------------

==== Integer Underflow ====
SWC ID: 101
Severity: High
Contract: GuessTheRandomNumberChallenge
Function name: recover()
PC address: 374
Estimated Gas Usage: 1033 - 1128
The binary subtraction can underflow.
The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.
--------------------
In file: cases/guess_the_random_number_fixed.sol:31

block.number - 256

--------------------

==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: GuessTheRandomNumberChallenge
Function name: recover()
PC address: 380
Estimated Gas Usage: 1033 - 1128
The binary addition can overflow.
The operands of the addition operation are not sufficiently constrained. The addition could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/guess_the_random_number_fixed.sol:31

commitBlock+20

--------------------

==== Dependence on Predictable Variable ====
SWC ID: 120
Severity: Low
Contract: GuessTheRandomNumberChallenge
Function name: recover()
PC address: 577
Estimated Gas Usage: 2491 - 3432
Sending of Ether depends on the blockhash.
The predictable expression 'block.blockhash(block.number)' is used to determine Ether recipient, this expression will always be equal to zero.
--------------------
In file: cases/guess_the_random_number_fixed.sol:35

msg.sender.transfer(2 ether)

--------------------

==== Dependence on predictable environment variable ====
SWC ID: 120
Severity: Low
Contract: GuessTheRandomNumberChallenge
Function name: recover()
PC address: 577
Estimated Gas Usage: 2491 - 3432
Sending of Ether depends on a predictable variable.
The contract sends Ether depending on the values of the following variables:
- block.number
- block.number
- block.number
Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions.
--------------------
In file: cases/guess_the_random_number_fixed.sol:35

msg.sender.transfer(2 ether)

--------------------

==== Unprotected Ether Withdrawal ====
SWC ID: 105
Severity: High
Contract: GuessTheRandomNumberChallenge
Function name: recover()
PC address: 577
Estimated Gas Usage: 2491 - 3432
Anyone can withdraw ETH from the contract account.
Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent an equivalent amount of ETH to it. This is likely to be a vulnerability.
--------------------
In file: cases/guess_the_random_number_fixed.sol:35

msg.sender.transfer(2 ether)

--------------------


The analysis was completed successfully. No issues were detected.

The analysis was completed successfully. No issues were detected.

==== Integer Overflow ====
SWC ID: 101
Severity: High
Contract: IntegerOverflowMul
Function name: run(uint256)
PC address: 207
Estimated Gas Usage: 692 - 787
The binary multiplication can overflow.
The operands of the multiplication operation are not sufficiently constrained. The multiplication could therefore result in an integer overflow. Prevent the overflow by checking inputs or ensure sure that the overflow is caught by an assertion.
--------------------
In file: cases/integer_overflow_mul_fixed.sol:23

a * b

--------------------


==== External Call To User-Supplied Address ====
SWC ID: 107
Severity: Medium
Contract: ModifierEntrancy
Function name: airDrop()
PC address: 294
Estimated Gas Usage: 933 - 1309
A call to a user-supplied address is executed.
The callee address of an external message call can be set by the caller. Note that the callee can contain arbitrary code and may re-enter any function in this contract. Review the business logic carefully to prevent averse effects on thecontract state.
--------------------
In file: cases/modifier_reentrancy_fixed.sol:14

Bank(msg.sender).supportsToken()

--------------------


==== Integer Underflow ====
SWC ID: 101
Severity: High
Contract: IntegerOverflowMinimal
Function name: run(uint256)
PC address: 174
Estimated Gas Usage: 633 - 728
The binary subtraction can underflow.
The operands of the subtraction operation are not sufficiently constrained. The subtraction could therefore result in an integer underflow. Prevent the underflow by checking inputs or ensure sure that the underflow is caught by an assertion.
--------------------
In file: cases/integer_overflow_minimal.sol:10

count -= input

--------------------


The analysis was completed successfully. No issues were detected.

